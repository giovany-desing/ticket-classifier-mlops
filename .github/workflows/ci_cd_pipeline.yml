name: CI/CD Pipeline - Validate & Deploy

on:
  push:
    branches:
      - main
  workflow_dispatch:
    inputs:
      skip_validation:
        description: 'Saltar validaciones (solo deploy)'
        required: false
        default: 'false'
        type: boolean

# Control de concurrencia
concurrency:
  group: ci-cd-pipeline-${{ github.ref }}
  cancel-in-progress: false

env:
  PYTHON_VERSION: '3.9'
  RENDER_SERVICE_NAME: ticket-classifier-api

jobs:
  # ========================================================================
  # JOB 1: VALIDACIONES
  # ========================================================================
  validate:
    name: Validate Project
    runs-on: ubuntu-latest
    timeout-minutes: 10
    if: ${{ !inputs.skip_validation }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Python ${{ env.PYTHON_VERSION }}
        uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}
          cache: 'pip'

      - name: Verify required files exist
        run: |
          echo "Verificando archivos requeridos..."

          for file in "api/inference.py" "requirements.txt" "config.yaml" "scripts/train_model.py" "utils/preprocessing_data.py" "utils/monitoring.py" "utils/database.py"; do
            if [ ! -f "$file" ]; then
              echo "ERROR: Archivo faltante: $file"
              exit 1
            else
              echo "OK: $file existe"
            fi
          done

          echo ""
          echo "Todos los archivos requeridos estan presentes"

      - name: Verify DVC files exist
        run: |
          echo "Verificando archivos DVC..."

          if [ ! -f "models/best_model.pkl.dvc" ]; then
            echo "WARN: models/best_model.pkl.dvc no existe"
            echo "  Esto es normal si es la primera vez, pero necesitaras entrenar un modelo"
          else
            echo "OK: models/best_model.pkl.dvc existe"
          fi

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip setuptools wheel
          pip install -r requirements.txt

      - name: Validate Python syntax
        run: |
          echo "Validando sintaxis de Python..."

          for file in "api/inference.py" "scripts/train_model.py" "scripts/monitor_and_retrain.py" "scripts/deploy_model.py" "utils/preprocessing_data.py" "utils/monitoring.py" "utils/database.py" "scripts/download_model.py"; do
            if [ -f "$file" ]; then
              echo "Validando $file..."
              python -m py_compile "$file" || {
                echo "ERROR: Error de sintaxis en $file"
                exit 1
              }
            fi
          done

          echo "Sintaxis valida en todos los archivos"

      - name: Validate imports
        run: |
          echo "Validando imports..."
          python -c "
          import sys
          import importlib.util

          def check_import(module_name, file_path):
              try:
                  spec = importlib.util.spec_from_file_location(module_name, file_path)
                  if spec is None:
                      print(f'ERROR: No se pudo cargar {file_path}')
                      return False
                  module = importlib.util.module_from_spec(spec)
                  print(f'OK: {file_path} puede importarse')
                  return True
              except SyntaxError as e:
                  print(f'ERROR: Error de sintaxis en {file_path}: {e}')
                  return False
              except Exception as e:
                  print(f'WARN: {file_path} tiene imports que pueden fallar: {e}')
                  return True

          files_to_check = [
              ('api.inference', 'api/inference.py'),
              ('utils.preprocessing_data', 'utils/preprocessing_data.py'),
              ('utils.monitoring', 'utils/monitoring.py'),
              ('utils.database', 'utils/database.py'),
          ]

          all_ok = True
          for module_name, file_path in files_to_check:
              if not check_import(module_name, file_path):
                  all_ok = False

          if not all_ok:
              sys.exit(1)

          print('Todos los imports son validos')
          "

      - name: Validate config.yaml
        run: |
          echo "Validando config.yaml..."
          python -c "
          import yaml
          import sys

          try:
              with open('config.yaml', 'r') as f:
                  config = yaml.safe_load(f)

              required_sections = ['data', 'preprocessing', 'monitoring', 'api']

              for section in required_sections:
                  if section not in config:
                      print(f'ERROR: Seccion faltante en config.yaml: {section}')
                      sys.exit(1)
                  print(f'OK: Seccion {section} presente')

              print('config.yaml es valido')

          except yaml.YAMLError as e:
              print(f'ERROR: Error parseando config.yaml: {e}')
              sys.exit(1)
          except Exception as e:
              print(f'ERROR: Error validando config.yaml: {e}')
              sys.exit(1)
          "

      - name: Validate render.yaml
        run: |
          if [ -f "render.yaml" ]; then
            echo "Validando render.yaml..."
            python -c "
          import yaml
          import sys

          try:
              with open('render.yaml', 'r') as f:
                  render_config = yaml.safe_load(f)

              if 'services' not in render_config:
                  print('ERROR: render.yaml debe tener seccion services')
                  sys.exit(1)

              print('render.yaml es valido')

          except yaml.YAMLError as e:
              print(f'ERROR: Error parseando render.yaml: {e}')
              sys.exit(1)
          except Exception as e:
              print(f'ERROR: Error validando render.yaml: {e}')
              sys.exit(1)
            "
          else
            echo "WARN: render.yaml no existe (opcional)"
          fi

  # ========================================================================
  # JOB 2: DEPLOY A RENDER
  # ========================================================================
  deploy:
    name: Deploy to Render
    runs-on: ubuntu-latest
    timeout-minutes: 15
    needs: validate
    if: |
      always() &&
      (needs.validate.result == 'success' || inputs.skip_validation == true)

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Trigger Render Deploy
        env:
          RENDER_DEPLOY_HOOK_URL: ${{ secrets.RENDER_DEPLOY_HOOK_URL }}
        run: |
          if [ -z "$RENDER_DEPLOY_HOOK_URL" ]; then
            echo "ERROR: RENDER_DEPLOY_HOOK_URL no esta configurado en secrets"
            echo ""
            echo "Para configurarlo:"
            echo "1. Ve a Render Dashboard -> tu servicio -> Settings -> Deploy Hook"
            echo "2. Copia la URL del Deploy Hook"
            echo "3. En GitHub -> Settings -> Secrets -> Actions -> New secret"
            echo "4. Nombre: RENDER_DEPLOY_HOOK_URL"
            echo "5. Valor: la URL copiada de Render"
            exit 1
          fi

          echo "Disparando deploy en Render..."
          echo "Todas las validaciones pasaron"

          RESPONSE=$(curl -s -w "\n%{http_code}" -X POST "$RENDER_DEPLOY_HOOK_URL")
          HTTP_CODE=$(echo "$RESPONSE" | tail -1)
          BODY=$(echo "$RESPONSE" | sed '$d')

          if [ "$HTTP_CODE" = "200" ] || [ "$HTTP_CODE" = "201" ]; then
            echo "Deploy disparado exitosamente en Render"
            echo "Respuesta: $BODY"
          else
            echo "ERROR: Error disparando deploy (HTTP $HTTP_CODE)"
            echo "Respuesta: $BODY"
            exit 1
          fi

      - name: Wait for deploy to start
        run: |
          echo "Esperando 30 segundos para que Render inicie el deploy..."
          sleep 30

      - name: Health check (post-deploy)
        env:
          API_URL: ${{ secrets.API_URL }}
        run: |
          if [ -z "$API_URL" ]; then
            echo "WARN: API_URL no configurada, saltando health check"
            echo "Configura API_URL en secrets para verificar el deploy"
            exit 0
          fi

          echo "Verificando health de la API..."

          MAX_ATTEMPTS=5
          ATTEMPT=1

          while [ $ATTEMPT -le $MAX_ATTEMPTS ]; do
            echo "Intento $ATTEMPT de $MAX_ATTEMPTS..."

            HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" \
              "$API_URL/health" \
              --max-time 10)

            if [ "$HTTP_CODE" = "200" ]; then
              echo "API respondiendo correctamente"
              exit 0
            fi

            echo "API no disponible (HTTP $HTTP_CODE), esperando 30s..."
            sleep 30
            ATTEMPT=$((ATTEMPT + 1))
          done

          echo "WARN: API no respondio despues de $MAX_ATTEMPTS intentos"
          echo "El deploy puede seguir en progreso. Verifica en Render Dashboard."

      - name: Generate summary
        if: always()
        env:
          API_URL: ${{ secrets.API_URL }}
        run: |
          echo "# Deploy Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Service:** ${{ env.RENDER_SERVICE_NAME }}" >> $GITHUB_STEP_SUMMARY
          echo "**Branch:** ${{ github.ref_name }}" >> $GITHUB_STEP_SUMMARY
          echo "**Commit:** ${{ github.sha }}" >> $GITHUB_STEP_SUMMARY
          echo "**Triggered by:** ${{ github.actor }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## Validations" >> $GITHUB_STEP_SUMMARY
          echo "- Validate: ${{ needs.validate.result }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          if [ -n "$API_URL" ]; then
            echo "## Links" >> $GITHUB_STEP_SUMMARY
            echo "- **API URL:** $API_URL" >> $GITHUB_STEP_SUMMARY
            echo "- **Health Check:** $API_URL/health" >> $GITHUB_STEP_SUMMARY
            echo "- **Docs:** $API_URL/docs" >> $GITHUB_STEP_SUMMARY
          fi

          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## Next Steps" >> $GITHUB_STEP_SUMMARY
          echo "1. Verify deployment in [Render Dashboard](https://dashboard.render.com)" >> $GITHUB_STEP_SUMMARY
          if [ -n "$API_URL" ]; then
            echo "2. Check API health: curl $API_URL/health" >> $GITHUB_STEP_SUMMARY
          fi
          echo "3. Test prediction endpoint" >> $GITHUB_STEP_SUMMARY

  # ========================================================================
  # JOB 3: NOTIFICACIONES
  # ========================================================================
  notify:
    name: Send Notifications
    runs-on: ubuntu-latest
    needs: [validate, deploy]
    if: always()  # Ejecutar siempre, incluso si fallan jobs anteriores
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
      
      - name: Setup Python ${{ env.PYTHON_VERSION }}
        uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}
      
      - name: Install dependencies
        run: |
          pip install requests
      
      - name: Send notification
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
          DISCORD_WEBHOOK_URL: ${{ secrets.DISCORD_WEBHOOK_URL }}
          TELEGRAM_BOT_TOKEN: ${{ secrets.TELEGRAM_BOT_TOKEN }}
          TELEGRAM_CHAT_ID: ${{ secrets.TELEGRAM_CHAT_ID }}
          VALIDATE_RESULT: ${{ needs.validate.result }}
          DEPLOY_RESULT: ${{ needs.deploy.result }}
          GITHUB_ACTOR: ${{ github.actor }}
          GITHUB_SHA: ${{ github.sha }}
          GITHUB_REF: ${{ github.ref_name }}
        run: |
          python - <<'EOF'
          import os
          import sys
          import requests
          import json
          from datetime import datetime

          # Resultados de los jobs
          validate_result = os.getenv('VALIDATE_RESULT', 'skipped')
          deploy_result = os.getenv('DEPLOY_RESULT', 'skipped')
          
          # Info del commit
          actor = os.getenv('GITHUB_ACTOR')
          sha = os.getenv('GITHUB_SHA', 'unknown')[:7]
          branch = os.getenv('GITHUB_REF', 'unknown')
          
          # Determinar estado general
          if deploy_result == 'success':
              status = 'success'
              emoji = '✅'
              color = '#00ff00'
          elif deploy_result == 'failure' or validate_result == 'failure':
              status = 'failure'
              emoji = '❌'
              color = '#ff0000'
          else:
              status = 'skipped'
              emoji = 'ℹ️'
              color = '#808080'
          
          # Construir mensaje
          message = f"{emoji} **CI/CD Pipeline {status.upper()}**\n\n"
          message += f"Branch: `{branch}`\n"
          message += f"Commit: `{sha}`\n"
          message += f"Author: {actor}\n\n"
          message += f"**Results:**\n"
          message += f"- Validate: {validate_result}\n"
          message += f"- Deploy: {deploy_result}\n"
          
          # Enviar a Slack
          slack_webhook = os.getenv('SLACK_WEBHOOK_URL')
          if slack_webhook:
              payload = {
                  "text": f"{emoji} CI/CD Pipeline {status.upper()}",
                  "attachments": [{
                      "color": color,
                      "fields": [
                          {"title": "Branch", "value": branch, "short": True},
                          {"title": "Commit", "value": sha, "short": True},
                          {"title": "Author", "value": actor, "short": True},
                          {"title": "Validate", "value": validate_result, "short": True},
                          {"title": "Deploy", "value": deploy_result, "short": True}
                      ],
                      "footer": "GitHub Actions",
                      "ts": int(datetime.now().timestamp())
                  }]
              }
              
              try:
                  r = requests.post(slack_webhook, json=payload, timeout=10)
                  if r.status_code == 200:
                      print("✅ Slack notification sent")
                  else:
                      print(f"⚠️  Slack notification failed: {r.status_code}")
              except Exception as e:
                  print(f"⚠️  Error sending Slack notification: {e}")
          
          # Enviar a Discord
          discord_webhook = os.getenv('DISCORD_WEBHOOK_URL')
          if discord_webhook:
              color_int = int(color.replace('#', ''), 16)
              
              payload = {
                  "embeds": [{
                      "title": f"{emoji} CI/CD Pipeline {status.upper()}",
                      "description": message,
                      "color": color_int,
                      "footer": {"text": "GitHub Actions"},
                      "timestamp": datetime.now().isoformat()
                  }]
              }
              
              try:
                  r = requests.post(discord_webhook, json=payload, timeout=10)
                  if r.status_code == 204:
                      print("✅ Discord notification sent")
                  else:
                      print(f"⚠️  Discord notification failed: {r.status_code}")
              except Exception as e:
                  print(f"⚠️  Error sending Discord notification: {e}")
          
          # Enviar a Telegram
          telegram_token = os.getenv('TELEGRAM_BOT_TOKEN')
          telegram_chat = os.getenv('TELEGRAM_CHAT_ID')
          if telegram_token and telegram_chat:
              url = f"https://api.telegram.org/bot{telegram_token}/sendMessage"
              payload = {
                  "chat_id": telegram_chat,
                  "text": message,
                  "parse_mode": "Markdown"
              }
              
              try:
                  r = requests.post(url, json=payload, timeout=10)
                  if r.status_code == 200:
                      print("✅ Telegram notification sent")
                  else:
                      print(f"⚠️  Telegram notification failed: {r.status_code}")
              except Exception as e:
                  print(f"⚠️  Error sending Telegram notification: {e}")
          
          # Si no hay webhooks configurados
          if not any([slack_webhook, discord_webhook, (telegram_token and telegram_chat)]):
              print("ℹ️  No notification webhooks configured")
              print("   Configure SLACK_WEBHOOK_URL, DISCORD_WEBHOOK_URL, or TELEGRAM_BOT_TOKEN + TELEGRAM_CHAT_ID in GitHub secrets")
          
          EOF















